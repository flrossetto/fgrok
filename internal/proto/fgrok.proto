syntax = "proto3";

package fgrok.v1;

option go_package = "github.com/flrossetto/fgrok/internal/proto;proto";

// ===================== Services =====================

// Bidirectional stream for HTTP frames.
// Direction mapping (as per your convention):
// - external → local   : HttpUpstream   (server → tunnel client; frames sent by the server)
// - local    → external: HttpDownstream (tunnel client → server; frames sent by the client)
service HttpTunnelService {
  rpc Stream (stream HttpDownstream) returns (stream HttpUpstream) {}
}

// Bidirectional stream for TCP frames.
// Direction mapping (as per your convention):
// - external → local   : TcpUpstream   (server → tunnel client; frames sent by the server)
// - local    → external: TcpDownstream (tunnel client → server; frames sent by the client)
service TcpTunnelService {
  rpc Stream (stream TcpDownstream) returns (stream TcpUpstream) {}
}

// ====================== HTTP ========================

// Upstream HTTP frame (server → tunnel client).
message HttpUpstream {
  // Unique request ID generated by the server and echoed by the client.
  string request_id = 1;
  // Raw HTTP wire data (request/response bytes depending on processing stage).
  bytes payload = 2;
}

// Downstream HTTP frame (tunnel client → server).
message HttpDownstream {
  // Corresponding request ID that pairs with HttpUpstream.request_id.
  string request_id = 1;
  // Raw HTTP wire data (request/response bytes depending on processing stage).
  bytes payload = 2;
}

// ======================= TCP ========================

// Upstream TCP frame (server → tunnel client).
message TcpUpstream {
  // Unique TCP connection identifier generated by the server and echoed by the client.
  string connection_id = 1;
  // Raw TCP payload bytes.
  bytes payload = 2;
}

// Downstream TCP frame (tunnel client → server).
message TcpDownstream {
  // Corresponding connection ID that pairs with TcpUpstream.connection_id.
  string connection_id = 1;
  // Raw TCP payload bytes.
  bytes payload = 2;
}
